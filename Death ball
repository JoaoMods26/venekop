-- JDeath BallMods con Interfaz JmodsLib
-- Cargar JmodsLib
local JmodsLib = loadstring(game:HttpGet('https://raw.githubusercontent.com/pruebasjoao/test/refs/heads/main/JmodsLibV1.0'))()

-- Servicios
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TweenService = game:GetService("TweenService")
local PathfindingService = game:GetService("PathfindingService")
local UserInputService = game:GetService("UserInputService")

-- Variables del jugador
local Player = Players.LocalPlayer

-- Variables del sistema de parry mejorado
local AutoParryEnabled = false
local AutoWalkEnabled = false
local ShowVisualizer = false
local ShowBallTrail = false
local ShowPredictionLine = false
local ShowVelocityIndicator = false
local ShowDistanceRings = false
local ShowBallESP = false
local ShowHitbox = false
local PlayParrySound = false
local ShowStatistics = false
local PredictiveParry = true
local ShowImpactPoint = false
local ShowBallPath = false
local ShowDangerZone = false
local ShowParryTiming = false
local UltraReactiveMode = false

local BallShadow = nil
local BallObject = nil
local PreviousPosition = nil
local LastParry = 0
local BallVelocityHistory = {}
local LastBallColor = Color3.new(1, 1, 1)
local WalkConnection = nil
local LastWalkPosition = nil
local ImpactPointPart = nil
local BallPathParts = {}
local DangerZonePart = nil
local TimingIndicator = nil
local LastActivationTime = 0

-- Sistema adaptativo de velocidad
local ParryHistory = {}
local LastParryCheckTime = 0
local IsInRapidMode = false
local RapidModeActivatedTime = 0

-- Colores personalizables
local Colors = {
    Zone = Color3.fromRGB(0, 255, 255),
    Trail = Color3.fromRGB(255, 0, 255),
    PredictionLine = Color3.fromRGB(0, 255, 0),
    Velocity = Color3.fromRGB(255, 255, 0),
    ESP = Color3.fromRGB(255, 0, 255),
    Hitbox = Color3.fromRGB(0, 255, 0)
}

-- Estadísticas
local Stats = {
    TotalParries = 0,
    SuccessfulParries = 0,
    FailedParries = 0,
    MissedBalls = 0,
    AverageDistance = 0,
    FastestParry = math.huge,
    SessionTime = 0,
    DistanceWalked = 0
}
local SessionStart = tick()

-- Variables ajustables mejoradas
local BaseDistance = 15
local VelocityMultiplier = 0.3
local ParryDelay = 0.01
local MinimumDistance = 3
local MaximumDistance = 40
local RequireApproaching = true
local ReactionTime = 0.15
local WalkSpeed = 16
local StopDistance = 8

-- Visualizadores
local VisualizerPart = nil
local BallTrail = nil
local PredictionLine = nil
local VelocityArrow = nil
local DistanceRings = {}
local BallESPBox = nil
local HitboxVisualizer = nil
local StatsGui = nil

-- Crear la ventana principal
local Window = JmodsLib:CreateWindow({
    Name = "JDeath BallMods",
    Icon = 90692784970350,
    LoadingTitle = "Cargando JDeath BallMods...",
    LoadingSubtitle = "Auto Walk + Auto Parry + 11 Visuales",
    Theme = "neon_blue",
    Intro = true,
    IntroIcon = 90692784970350,
    AnimationIntro = 2,
    DragImage = 127271155083726
})

JmodsLib:Notify({
    Title = "JDeath BallMods",
    Content = "Sistema completo con 11 visuales diferentes",
    Duration = 5,
    Image = 13458017478
})

-- Crear Tabs
local MainTab = Window:CreateTab("Principal")
local VisualsTab = Window:CreateTab("Visuales")
local ColorsTab = Window:CreateTab("Colores")
local AdvancedTab = Window:CreateTab("Avanzado")
local StatsTab = Window:CreateTab("Stats")

-- ========================================
-- SISTEMA ADAPTATIVO DE VELOCIDAD
-- ========================================

local function UpdateAdaptiveSpeed()
    if not UltraReactiveMode then
        IsInRapidMode = false
        ParryHistory = {}
        return
    end
    
    local currentTime = tick()
    
    -- Limpiar historial antiguo (más de 5 segundos)
    local cleanedHistory = {}
    for _, parryTime in ipairs(ParryHistory) do
        if currentTime - parryTime <= 5 then
            table.insert(cleanedHistory, parryTime)
        end
    end
    ParryHistory = cleanedHistory
    
    -- Verificar si hay 4+ parries exitosos en los últimos 5 segundos
    if #ParryHistory >= 4 and not IsInRapidMode then
        IsInRapidMode = true
        RapidModeActivatedTime = currentTime
        JmodsLib:Notify({
            Title = "MODO RAPIDO ACTIVADO",
            Content = "Parries acelerados por alta actividad",
            Duration = 2
        })
    end
    
    -- Si está en modo rápido, verificar si debe desactivarse
    if IsInRapidMode then
        local timeSinceLastParry = currentTime - LastParryCheckTime
        local timeSinceActivation = currentTime - RapidModeActivatedTime
        
        -- Desactivar si han pasado 2 segundos sin parry Y han pasado al menos 3 segundos desde activación
        if timeSinceLastParry >= 2 and timeSinceActivation >= 3 then
            IsInRapidMode = false
            ParryHistory = {}
            JmodsLib:Notify({
                Title = "Modo Normal",
                Content = "Velocidad de parry restaurada",
                Duration = 2
            })
        end
    end
end

local function RegisterSuccessfulParry()
    if not UltraReactiveMode then return end
    
    local currentTime = tick()
    table.insert(ParryHistory, currentTime)
    LastParryCheckTime = currentTime
    
    UpdateAdaptiveSpeed()
end

-- ========================================
-- FUNCIONES MEJORADAS
-- ========================================

local function GetBallColor(target)
    if not target then return Color3.new(1, 1, 1) end
    local highlight = target:FindFirstChildOfClass("Highlight")
    if highlight then return highlight.FillColor end
    return target:IsA("Part") and target.Color or Color3.new(1, 1, 1)
end

local function GetVisualHeight(shadow)
    if not shadow then return 0 end
    return math.min(((math.max(0, shadow.Size.X - 5)) * 20) + 3, 100)
end

local function IsBallApproaching(currentPos, previousPos, playerPos)
    if not previousPos then return false end
    local currentDist = (currentPos - playerPos).Magnitude
    local previousDist = (previousPos - playerPos).Magnitude
    return currentDist < previousDist
end

local function GetAverageBallVelocity()
    if #BallVelocityHistory < 2 then return 0 end
    local sum = 0
    for i = 1, math.min(3, #BallVelocityHistory) do
        sum = sum + BallVelocityHistory[#BallVelocityHistory - i + 1]
    end
    return sum / math.min(3, #BallVelocityHistory)
end

local function CalculatePredictiveDistance(velocity, distance, ping)
    if velocity == 0 then return BaseDistance end
    
    local pingCompensation = ping * 50
    local velocityFactor = math.clamp(velocity / 100, 0.5, 2)
    local distanceFactor = 1 + (distance / 100)
    
    local dynamicDistance = BaseDistance + pingCompensation + (velocity * VelocityMultiplier * velocityFactor * distanceFactor)
    return math.clamp(dynamicDistance, MinimumDistance, MaximumDistance)
end

local function IsBallActive(color)
    return color ~= Color3.new(1, 1, 1)
end

-- ========================================
-- SISTEMA DE PARRY (ORIGINAL + SOPORTE MOVIL)
-- ========================================

local function TriggerParry()
    -- METODO 1: Tecla F (funciona en PC y algunos móviles)
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
        task.wait(0.01)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
    end)
    
    -- METODO 2: Activar tool directamente (funciona en móvil)
    task.spawn(function()
        local tool = Player.Character and Player.Character:FindFirstChildOfClass("Tool")
        if tool then
            pcall(function()
                tool:Activate()
            end)
        end
    end)
    
    if PlayParrySound then
        local sound = Instance.new("Sound")
        sound.SoundId = "rbxassetid://6723516732"
        sound.Volume = 0.5
        sound.Parent = game:GetService("SoundService")
        sound:Play()
        game:GetService("Debris"):AddItem(sound, 1)
    end
end

-- ========================================
-- FUNCIÓN AUTO WALK (ORIGINAL)
-- ========================================

local function WalkToBall()
    if not AutoWalkEnabled then
        if WalkConnection then
            WalkConnection:Disconnect()
            WalkConnection = nil
        end
        -- Detener el personaje
        local character = Player.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.WalkSpeed = 16
            character.Humanoid:MoveTo(character.HumanoidRootPart.Position)
        end
        return
    end
    
    if WalkConnection then return end
    
    WalkConnection = RunService.Heartbeat:Connect(function(dt)
        if not AutoWalkEnabled or not Player.Character or not Player.Character.PrimaryPart then return end
        if not BallShadow or not BallShadow.Parent then return end
        
        local character = Player.Character
        local humanoid = character:FindFirstChild("Humanoid")
        local rootPart = character.PrimaryPart
        
        if not humanoid then return end
        
        local ballPos = BallShadow.Position
        local playerPos = rootPart.Position
        
        local flatBallPos = Vector3.new(ballPos.X, playerPos.Y, ballPos.Z)
        local distance = (flatBallPos - playerPos).Magnitude
        
        if distance > StopDistance then
            humanoid.WalkSpeed = WalkSpeed
            humanoid:MoveTo(flatBallPos)
            
            if LastWalkPosition then
                Stats.DistanceWalked = Stats.DistanceWalked + (playerPos - LastWalkPosition).Magnitude
            end
            LastWalkPosition = playerPos
        else
            humanoid:MoveTo(playerPos)
        end
    end)
end

-- ========================================
-- VISUALIZADORES
-- ========================================

local function UpdateVisualizer(position, distance)
    if not ShowVisualizer then
        if VisualizerPart then
            VisualizerPart:Destroy()
            VisualizerPart = nil
        end
        return
    end
    
    if not VisualizerPart then
        VisualizerPart = Instance.new("Part")
        VisualizerPart.Name = "ParryZone"
        VisualizerPart.Anchored = true
        VisualizerPart.CanCollide = false
        VisualizerPart.Material = Enum.Material.ForceField
        VisualizerPart.Transparency = 0.7
        VisualizerPart.Shape = Enum.PartType.Ball
        VisualizerPart.Parent = workspace
    end
    
    VisualizerPart.Position = position
    VisualizerPart.Size = Vector3.new(distance * 2, distance * 2, distance * 2)
    VisualizerPart.Color = Colors.Zone
end

local function UpdateBallTrail(ball)
    if not ShowBallTrail then
        if BallTrail then
            BallTrail:Destroy()
            BallTrail = nil
        end
        return
    end
    
    if not BallTrail and ball then
        BallTrail = Instance.new("Trail")
        BallTrail.Lifetime = 0.5
        BallTrail.MinLength = 0
        BallTrail.FaceCamera = true
        BallTrail.Color = ColorSequence.new(Colors.Trail)
        BallTrail.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0.5),
            NumberSequenceKeypoint.new(1, 1)
        })
        BallTrail.WidthScale = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 1),
            NumberSequenceKeypoint.new(1, 0)
        })
        
        local a0 = Instance.new("Attachment")
        a0.Position = Vector3.new(0, 0, 0)
        a0.Parent = ball
        
        local a1 = Instance.new("Attachment")
        a1.Position = Vector3.new(0, 0, 0)
        a1.Parent = ball
        
        BallTrail.Attachment0 = a0
        BallTrail.Attachment1 = a1
        BallTrail.Parent = ball
    end
end

local function UpdatePredictionLine(playerPos, ballPos, distance, isApproaching)
    if not ShowPredictionLine then
        if PredictionLine then
            PredictionLine:Destroy()
            PredictionLine = nil
        end
        return
    end
    
    if not PredictionLine then
        PredictionLine = Instance.new("Part")
        PredictionLine.Name = "PredictionLine"
        PredictionLine.Anchored = true
        PredictionLine.CanCollide = false
        PredictionLine.Material = Enum.Material.Neon
        PredictionLine.Transparency = 0.5
        PredictionLine.Parent = workspace
    end
    
    local midPoint = (playerPos + ballPos) / 2
    PredictionLine.Size = Vector3.new(0.2, 0.2, distance)
    PredictionLine.CFrame = CFrame.lookAt(midPoint, ballPos)
    PredictionLine.Color = isApproaching and Colors.PredictionLine or Color3.fromRGB(255, 0, 0)
end

local function UpdateVelocityIndicator(position, velocity, direction)
    if not ShowVelocityIndicator then
        if VelocityArrow then
            VelocityArrow:Destroy()
            VelocityArrow = nil
        end
        return
    end
    
    if not VelocityArrow then
        VelocityArrow = Instance.new("Part")
        VelocityArrow.Name = "VelocityArrow"
        VelocityArrow.Anchored = true
        VelocityArrow.CanCollide = false
        VelocityArrow.Material = Enum.Material.Neon
        VelocityArrow.Transparency = 0.3
        VelocityArrow.Parent = workspace
    end
    
    local arrowLength = math.clamp(velocity / 10, 2, 20)
    VelocityArrow.Size = Vector3.new(0.5, 0.5, arrowLength)
    VelocityArrow.CFrame = CFrame.lookAt(position, position + direction)
    VelocityArrow.Color = Colors.Velocity
end

local function UpdateDistanceRings(position)
    if not ShowDistanceRings then
        for _, ring in ipairs(DistanceRings) do
            ring:Destroy()
        end
        DistanceRings = {}
        return
    end
    
    local distances = {10, 20, 30}
    
    while #DistanceRings < #distances do
        local ring = Instance.new("Part")
        ring.Name = "DistanceRing"
        ring.Anchored = true
        ring.CanCollide = false
        ring.Material = Enum.Material.Neon
        ring.Transparency = 0.8
        ring.Shape = Enum.PartType.Cylinder
        ring.Parent = workspace
        table.insert(DistanceRings, ring)
    end
    
    for i, ring in ipairs(DistanceRings) do
        local dist = distances[i]
        ring.Size = Vector3.new(0.2, dist * 2, dist * 2)
        ring.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
        ring.Color = Color3.fromRGB(0, 255 - (i * 50), 255)
    end
end

local function UpdateBallESP(ball)
    if not ShowBallESP then
        if BallESPBox then
            BallESPBox:Destroy()
            BallESPBox = nil
        end
        return
    end
    
    if not BallESPBox and ball then
        BallESPBox = Instance.new("BoxHandleAdornment")
        BallESPBox.Adornee = ball
        BallESPBox.Size = ball.Size + Vector3.new(0.5, 0.5, 0.5)
        BallESPBox.Color3 = Colors.ESP
        BallESPBox.Transparency = 0.5
        BallESPBox.AlwaysOnTop = true
        BallESPBox.ZIndex = 10
        BallESPBox.Parent = ball
    end
end

local function UpdateHitbox(character)
    if not ShowHitbox then
        if HitboxVisualizer then
            HitboxVisualizer:Destroy()
            HitboxVisualizer = nil
        end
        return
    end
    
    if not HitboxVisualizer and character and character.PrimaryPart then
        HitboxVisualizer = Instance.new("Part")
        HitboxVisualizer.Name = "Hitbox"
        HitboxVisualizer.Anchored = true
        HitboxVisualizer.CanCollide = false
        HitboxVisualizer.Material = Enum.Material.ForceField
        HitboxVisualizer.Transparency = 0.7
        HitboxVisualizer.Size = Vector3.new(5, 6, 5)
        HitboxVisualizer.Color = Colors.Hitbox
        HitboxVisualizer.Parent = workspace
    end
    
    if HitboxVisualizer and character and character.PrimaryPart then
        HitboxVisualizer.Position = character.PrimaryPart.Position
    end
end

local function UpdateImpactPoint(ballPos, velocity, direction)
    if not ShowImpactPoint then
        if ImpactPointPart then
            ImpactPointPart:Destroy()
            ImpactPointPart = nil
        end
        return
    end
    
    if not ImpactPointPart then
        ImpactPointPart = Instance.new("Part")
        ImpactPointPart.Name = "ImpactPoint"
        ImpactPointPart.Anchored = true
        ImpactPointPart.CanCollide = false
        ImpactPointPart.Material = Enum.Material.Neon
        ImpactPointPart.Transparency = 0.3
        ImpactPointPart.Shape = Enum.PartType.Ball
        ImpactPointPart.Size = Vector3.new(2, 2, 2)
        ImpactPointPart.Color = Color3.fromRGB(255, 100, 0)
        ImpactPointPart.Parent = workspace
    end
    
    local timeToGround = math.max(ballPos.Y / (velocity / 10), 0.1)
    local impactPos = ballPos + (direction * velocity * timeToGround)
    ImpactPointPart.Position = impactPos
end

local function UpdateBallPath(currentPos)
    table.insert(BallPathParts, 1, currentPos)
    
    if #BallPathParts > 10 then
        table.remove(BallPathParts)
    end
    
    for i, pos in ipairs(BallPathParts) do
        local part = workspace:FindFirstChild("PathPoint" .. i)
        if not part then
            part = Instance.new("Part")
            part.Name = "PathPoint" .. i
            part.Anchored = true
            part.CanCollide = false
            part.Material = Enum.Material.Neon
            part.Shape = Enum.PartType.Ball
            part.Size = Vector3.new(0.5, 0.5, 0.5)
            part.Parent = workspace
        end
        
        part.Position = pos
        part.Transparency = 0.3 + (i * 0.07)
        part.Color = Color3.fromRGB(255, 255 - (i * 25), 0)
    end
end

local function UpdateDangerZone(playerPos, ballPos, distance)
    if not ShowDangerZone then
        if DangerZonePart then
            DangerZonePart:Destroy()
            DangerZonePart = nil
        end
        return
    end
    
    if not DangerZonePart then
        DangerZonePart = Instance.new("Part")
        DangerZonePart.Name = "DangerZone"
        DangerZonePart.Anchored = true
        DangerZonePart.CanCollide = false
        DangerZonePart.Material = Enum.Material.ForceField
        DangerZonePart.Transparency = 0.7
        DangerZonePart.Shape = Enum.PartType.Ball
        DangerZonePart.Parent = workspace
    end
    
    local dangerLevel = math.clamp(1 - (distance / 30), 0, 1)
    DangerZonePart.Position = playerPos
    DangerZonePart.Size = Vector3.new(15, 15, 15)
    DangerZonePart.Color = Color3.fromRGB(255 * dangerLevel, 255 * (1 - dangerLevel), 0)
end

local function UpdateParryTiming(currentDist, targetDist, isApproaching)
    if not ShowParryTiming then
        if TimingIndicator then
            TimingIndicator:Destroy()
            TimingIndicator = nil
        end
        return
    end
    
    if not TimingIndicator then
        TimingIndicator = Instance.new("BillboardGui")
        TimingIndicator.Name = "TimingIndicator"
        TimingIndicator.AlwaysOnTop = true
        TimingIndicator.Size = UDim2.new(0, 100, 0, 50)
        TimingIndicator.StudsOffset = Vector3.new(0, 3, 0)
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundTransparency = 0.5
        frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        frame.Parent = TimingIndicator
        
        local label = Instance.new("TextLabel")
        label.Name = "Label"
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextSize = 18
        label.Font = Enum.Font.GothamBold
        label.Parent = frame
    end
    
    if Player.Character and Player.Character.PrimaryPart then
        TimingIndicator.Adornee = Player.Character.PrimaryPart
        TimingIndicator.Parent = Player.Character.PrimaryPart
        
        local label = TimingIndicator:FindFirstChild("Frame"):FindFirstChild("Label")
        if label then
            local percentage = math.clamp((currentDist / targetDist) * 100, 0, 100)
            local status = "ESPERANDO"
            local color = Color3.fromRGB(255, 255, 255)
            
            if isApproaching then
                if percentage <= 110 and percentage >= 90 then
                    status = "PERFECTO!"
                    color = Color3.fromRGB(0, 255, 0)
                elseif percentage <= 130 and percentage >= 70 then
                    status = "BUENO"
                    color = Color3.fromRGB(255, 255, 0)
                else
                    status = "ESPERANDO"
                    color = Color3.fromRGB(255, 100, 0)
                end
            end
            
            label.Text = string.format("%s\n%.1f%%", status, percentage)
            label.TextColor3 = color
        end
    end
end

-- ========================================
-- INTERFAZ PRINCIPAL
-- ========================================

MainTab:CreateSection("Sistema Auto")

MainTab:CreateToggle({
    Name = "Auto Parry",
    CurrentValue = false,
    Callback = function(state)
        AutoParryEnabled = state
        JmodsLib:Notify({
            Title = "Auto Parry",
            Content = state and "Activado" or "Desactivado",
            Duration = 2
        })
    end
})

MainTab:CreateToggle({
    Name = "Auto Walk",
    CurrentValue = false,
    Callback = function(state)
        AutoWalkEnabled = state
        WalkToBall()
        JmodsLib:Notify({
            Title = "Auto Walk",
            Content = state and "Activado" or "Desactivado",
            Duration = 2
        })
    end
})

MainTab:CreateToggle({
    Name = "Modo Ultra-Reactivo",
    CurrentValue = false,
    Callback = function(state)
        UltraReactiveMode = state
        if not state then
            IsInRapidMode = false
            ParryHistory = {}
        end
        JmodsLib:Notify({
            Title = "Modo Ultra-Reactivo",
            Content = state and "Activado - Sistema adaptativo" or "Desactivado",
            Duration = 3
        })
    end
})

MainTab:CreateSection("Configuración")

MainTab:CreateSlider({
    Name = "Velocidad de Caminar",
    Range = {8, 32},
    Increment = 1,
    CurrentValue = WalkSpeed,
    Callback = function(value)
        WalkSpeed = value
    end
})

MainTab:CreateSlider({
    Name = "Distancia de Parada",
    Range = {3, 15},
    Increment = 0.5,
    CurrentValue = StopDistance,
    Callback = function(value)
        StopDistance = value
    end
})

MainTab:CreateSlider({
    Name = "Distancia Base",
    Range = {5, 30},
    Increment = 1,
    CurrentValue = BaseDistance,
    Callback = function(value)
        BaseDistance = value
    end
})

MainTab:CreateSlider({
    Name = "Distancia Mínima",
    Range = {1, 10},
    Increment = 0.5,
    CurrentValue = MinimumDistance,
    Callback = function(value)
        MinimumDistance = value
    end
})

MainTab:CreateSlider({
    Name = "Distancia Máxima",
    Range = {20, 60},
    Increment = 2,
    CurrentValue = MaximumDistance,
    Callback = function(value)
        MaximumDistance = value
    end
})

-- ========================================
-- TAB DE VISUALES
-- ========================================

VisualsTab:CreateSection("Visualizadores Básicos")

VisualsTab:CreateToggle({
    Name = "Zona de Parry",
    CurrentValue = false,
    Callback = function(state)
        ShowVisualizer = state
        if not state then
            UpdateVisualizer(Vector3.new(0, 0, 0), 0)
        end
    end
})

VisualsTab:CreateToggle({
    Name = "Trail de la Pelota",
    CurrentValue = false,
    Callback = function(state)
        ShowBallTrail = state
        if not state then
            UpdateBallTrail(nil)
        end
    end
})

VisualsTab:CreateToggle({
    Name = "Línea de Predicción",
    CurrentValue = false,
    Callback = function(state)
        ShowPredictionLine = state
    end
})

VisualsTab:CreateSection("Visualizadores Avanzados")

VisualsTab:CreateToggle({
    Name = "Indicador de Velocidad",
    CurrentValue = false,
    Callback = function(state)
        ShowVelocityIndicator = state
    end
})

VisualsTab:CreateToggle({
    Name = "Anillos de Distancia",
    CurrentValue = false,
    Callback = function(state)
        ShowDistanceRings = state
    end
})

VisualsTab:CreateToggle({
    Name = "ESP de la Pelota",
    CurrentValue = false,
    Callback = function(state)
        ShowBallESP = state
    end
})

VisualsTab:CreateToggle({
    Name = "Visualizador de Hitbox",
    CurrentValue = false,
    Callback = function(state)
        ShowHitbox = state
    end
})

VisualsTab:CreateSection("Visualizadores Extra")

VisualsTab:CreateToggle({
    Name = "Punto de Impacto",
    CurrentValue = false,
    Callback = function(state)
        ShowImpactPoint = state
    end
})

VisualsTab:CreateToggle({
    Name = "Camino de la Pelota",
    CurrentValue = false,
    Callback = function(state)
        ShowBallPath = state
        if not state then
            for i = 1, 10 do
                local part = workspace:FindFirstChild("PathPoint" .. i)
                if part then
                    part:Destroy()
                end
            end
            BallPathParts = {}
        end
    end
})

VisualsTab:CreateToggle({
    Name = "Zona de Peligro",
    CurrentValue = false,
    Callback = function(state)
        ShowDangerZone = state
    end
})

VisualsTab:CreateToggle({
    Name = "Timing de Parry",
    CurrentValue = false,
    Callback = function(state)
        ShowParryTiming = state
    end
})

-- ========================================
-- TAB DE COLORES
-- ========================================

ColorsTab:CreateSection("Personalización de Colores")

ColorsTab:CreateColorPicker({
    Name = "Zona de Parry",
    Color = Colors.Zone,
    Callback = function(color)
        Colors.Zone = color
        if VisualizerPart then
            VisualizerPart.Color = color
        end
    end
})

ColorsTab:CreateColorPicker({
    Name = "Trail de Pelota",
    Color = Colors.Trail,
    Callback = function(color)
        Colors.Trail = color
        if BallTrail then
            BallTrail.Color = ColorSequence.new(color)
        end
    end
})

ColorsTab:CreateColorPicker({
    Name = "Línea de Predicción",
    Color = Colors.PredictionLine,
    Callback = function(color)
        Colors.PredictionLine = color
    end
})

ColorsTab:CreateColorPicker({
    Name = "Indicador de Velocidad",
    Color = Colors.Velocity,
    Callback = function(color)
        Colors.Velocity = color
        if VelocityArrow then
            VelocityArrow.Color = color
        end
    end
})

ColorsTab:CreateColorPicker({
    Name = "ESP de Pelota",
    Color = Colors.ESP,
    Callback = function(color)
        Colors.ESP = color
        if BallESPBox then
            BallESPBox.Color3 = color
        end
    end
})

ColorsTab:CreateColorPicker({
    Name = "Hitbox",
    Color = Colors.Hitbox,
    Callback = function(color)
        Colors.Hitbox = color
        if HitboxVisualizer then
            HitboxVisualizer.Color = color
        end
    end
})

-- ========================================
-- TAB AVANZADO
-- ========================================

AdvancedTab:CreateSection("Configuración Avanzada")

AdvancedTab:CreateToggle({
    Name = "Parry Predictivo",
    CurrentValue = true,
    Callback = function(state)
        PredictiveParry = state
    end
})

AdvancedTab:CreateToggle({
    Name = "Requerir Acercamiento",
    CurrentValue = true,
    Callback = function(state)
        RequireApproaching = state
    end
})

AdvancedTab:CreateToggle({
    Name = "Sonido de Parry",
    CurrentValue = false,
    Callback = function(state)
        PlayParrySound = state
    end
})

AdvancedTab:CreateSlider({
    Name = "Multiplicador de Velocidad",
    Range = {0.1, 1.0},
    Increment = 0.05,
    CurrentValue = VelocityMultiplier,
    Callback = function(value)
        VelocityMultiplier = value
    end
})

AdvancedTab:CreateSlider({
    Name = "Delay de Parry (ms)",
    Range = {0, 100},
    Increment = 5,
    CurrentValue = ParryDelay * 1000,
    Callback = function(value)
        ParryDelay = value / 1000
    end
})

AdvancedTab:CreateSlider({
    Name = "Tiempo de Reacción (ms)",
    Range = {50, 300},
    Increment = 10,
    CurrentValue = ReactionTime * 1000,
    Callback = function(value)
        ReactionTime = value / 1000
    end
})

-- ========================================
-- TAB DE ESTADISTICAS
-- ========================================

local function UpdateStatsDisplay()
    if not ShowStatistics then
        if StatsGui then
            StatsGui:Destroy()
            StatsGui = nil
        end
        return
    end
    
    if not StatsGui then
        StatsGui = Instance.new("ScreenGui")
        StatsGui.Name = "StatsDisplay"
        StatsGui.ResetOnSpawn = false
        StatsGui.Parent = Player:WaitForChild("PlayerGui")
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 250, 0, 200)
        frame.Position = UDim2.new(0, 10, 0.5, -100)
        frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        frame.BackgroundTransparency = 0.3
        frame.BorderSizePixel = 0
        frame.Parent = StatsGui
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 10)
        corner.Parent = frame
        
        local statsText = Instance.new("TextLabel")
        statsText.Name = "StatsText"
        statsText.Size = UDim2.new(1, -10, 1, -10)
        statsText.Position = UDim2.new(0, 5, 0, 5)
        statsText.BackgroundTransparency = 1
        statsText.TextColor3 = Color3.fromRGB(255, 255, 255)
        statsText.TextSize = 13
        statsText.Font = Enum.Font.Gotham
        statsText.TextXAlignment = Enum.TextXAlignment.Left
        statsText.TextYAlignment = Enum.TextYAlignment.Top
        statsText.Parent = frame
    end
    
    local successRate = Stats.TotalParries > 0 and (Stats.SuccessfulParries / Stats.TotalParries * 100) or 0
    Stats.SessionTime = tick() - SessionStart
    local ping = Player:GetNetworkPing() * 1000
    
    local statsText = StatsGui:FindFirstChild("Frame"):FindFirstChild("StatsText")
    if statsText then
        local modeText = IsInRapidMode and "RAPIDO" or "NORMAL"
        statsText.Text = string.format(
            "Parries: %d (%.1f%%)\nExitosos: %d\nDist. Prom: %.1f\nDist. Caminada: %.1f\nTiempo: %.0fs\nPing: %.0fms\nVel. Prom: %.1f\nAuto Walk: %s\nModo: %s",
            Stats.TotalParries,
            successRate,
            Stats.SuccessfulParries,
            Stats.AverageDistance,
            Stats.DistanceWalked,
            Stats.SessionTime,
            ping,
            GetAverageBallVelocity(),
            AutoWalkEnabled and "ON" or "OFF",
            UltraReactiveMode and modeText or "DESACTIVADO"
        )
    end
end

StatsTab:CreateToggle({
    Name = "Mostrar Estadísticas",
    CurrentValue = false,
    Callback = function(state)
        ShowStatistics = state
        UpdateStatsDisplay()
    end
})

StatsTab:CreateButton({
    Name = "Resetear Stats",
    Callback = function()
        Stats = {
            TotalParries = 0,
            SuccessfulParries = 0,
            FailedParries = 0,
            MissedBalls = 0,
            AverageDistance = 0,
            FastestParry = math.huge,
            SessionTime = 0,
            DistanceWalked = 0
        }
        SessionStart = tick()
        BallVelocityHistory = {}
        
        JmodsLib:Notify({
            Title = "Stats Reseteadas",
            Content = "Estadísticas reiniciadas",
            Duration = 2
        })
    end
})

StatsTab:CreateSection("Información")

StatsTab:CreateParagraph({
    Title = "Auto Walk",
    Content = "El Auto Walk hace que tu personaje camine automáticamente hacia la pelota manteniendo contacto con el suelo.\n\n⚙️ Puedes ajustar la velocidad y la distancia de parada en el Tab Principal."
})

-- ========================================
-- LOOP PRINCIPAL MEJORADO
-- ========================================
local ParryConnection = RunService.RenderStepped:Connect(function(dt)
    BallShadow = (BallShadow and BallShadow.Parent) and BallShadow or workspace.FX:FindFirstChild("BallShadow")
    BallObject = (BallObject and BallObject.Parent) and BallObject or (workspace:FindFirstChild("Ball") or workspace:FindFirstChild("Part"))
    
    if not BallShadow or not BallObject or not Player.Character or not Player.Character.PrimaryPart then
        PreviousPosition = nil
        return
    end
    
    local rootPart = Player.Character.PrimaryPart
    local height = GetVisualHeight(BallShadow)
    local currentPos = Vector3.new(BallShadow.Position.X, BallShadow.Position.Y + height, BallShadow.Position.Z)
    local ballColor = GetBallColor(BallObject)
    
    -- Actualizar visuales
    UpdateBallTrail(BallObject)
    UpdateBallESP(BallObject)
    UpdateHitbox(Player.Character)
    UpdateDistanceRings(rootPart.Position)
    
    if PreviousPosition then
        local velocity = (currentPos - PreviousPosition).Magnitude / dt
        local direction = (currentPos - PreviousPosition).Unit
        local isApproaching = IsBallApproaching(currentPos, PreviousPosition, rootPart.Position)
        local flatDistance = (Vector3.new(rootPart.Position.X, 0, rootPart.Position.Z) - Vector3.new(currentPos.X, 0, currentPos.Z)).Magnitude
        
        table.insert(BallVelocityHistory, velocity)
        if #BallVelocityHistory > 3 then
            table.remove(BallVelocityHistory, 1)
        end
        
        local ping = Player:GetNetworkPing()
        local dynamicDistance
        
        if PredictiveParry then
            dynamicDistance = CalculatePredictiveDistance(velocity, flatDistance, ping)
        else
            dynamicDistance = BaseDistance + (velocity * ping * VelocityMultiplier)
        end
        
        dynamicDistance = math.clamp(dynamicDistance, MinimumDistance, MaximumDistance)
        
        UpdateVisualizer(rootPart.Position, dynamicDistance)
        UpdatePredictionLine(rootPart.Position, currentPos, flatDistance, isApproaching)
        UpdateVelocityIndicator(currentPos, velocity, direction)
        UpdateImpactPoint(currentPos, velocity, direction)
        UpdateDangerZone(rootPart.Position, currentPos, flatDistance)
        UpdateParryTiming(flatDistance, dynamicDistance, isApproaching)
        
        if ShowBallPath then
            UpdateBallPath(currentPos)
        end
        
        if ShowStatistics then
            UpdateStatsDisplay()
        end
        
        -- Auto Parry logic mejorado con sistema adaptativo
        if AutoParryEnabled then
            local ballIsActive = IsBallActive(ballColor)
            local wasInactive = LastBallColor == Color3.new(1, 1, 1)
            local justActivated = ballIsActive and wasInactive
            
            -- Registrar tiempo de activación
            if justActivated then
                LastActivationTime = tick()
            end
            
            local timeSinceActivation = tick() - LastActivationTime
            local inRange = flatDistance >= MinimumDistance and flatDistance <= dynamicDistance
            local cooldownOk = (tick() - LastParry) > ParryDelay
            local directionOk = not RequireApproaching or isApproaching
            
            -- Actualizar sistema adaptativo
            if UltraReactiveMode then
                UpdateAdaptiveSpeed()
            end
            
            -- MODO RAPIDO ADAPTATIVO: Activado cuando hay alta actividad
            if UltraReactiveMode and IsInRapidMode then
                -- En modo rápido, aumentar el rango y reducir requisitos
                local extendedRange = flatDistance <= (dynamicDistance * 1.6) and flatDistance >= (MinimumDistance * 0.6)
                
                if ballIsActive and extendedRange and cooldownOk then
                    TriggerParry()
                    LastParry = tick()
                    RegisterSuccessfulParry()
                    
                    Stats.TotalParries = Stats.TotalParries + 1
                    Stats.SuccessfulParries = Stats.SuccessfulParries + 1
                    Stats.AverageDistance = ((Stats.AverageDistance * (Stats.TotalParries - 1)) + flatDistance) / Stats.TotalParries
                    
                    if flatDistance < Stats.FastestParry then
                        Stats.FastestParry = flatDistance
                    end
                end
            -- MODO ULTRA-REACTIVO INICIAL: Primeros 0.3s después de activación (solo si no está en modo rápido)
            elseif UltraReactiveMode and not IsInRapidMode and ballIsActive and timeSinceActivation < 0.3 then
                local extendedRange = flatDistance <= (dynamicDistance * 1.5) and flatDistance >= (MinimumDistance * 0.7)
                
                if extendedRange and cooldownOk then
                    TriggerParry()
                    LastParry = tick()
                    RegisterSuccessfulParry()
                    
                    Stats.TotalParries = Stats.TotalParries + 1
                    Stats.SuccessfulParries = Stats.SuccessfulParries + 1
                    Stats.AverageDistance = ((Stats.AverageDistance * (Stats.TotalParries - 1)) + flatDistance) / Stats.TotalParries
                    
                    if flatDistance < Stats.FastestParry then
                        Stats.FastestParry = flatDistance
                    end
                end
            -- PARRY NORMAL: Lógica estándar
            elseif ballIsActive and inRange and cooldownOk and directionOk then
                TriggerParry()
                LastParry = tick()
                
                if UltraReactiveMode then
                    RegisterSuccessfulParry()
                end
                
                Stats.TotalParries = Stats.TotalParries + 1
                Stats.SuccessfulParries = Stats.SuccessfulParries + 1
                Stats.AverageDistance = ((Stats.AverageDistance * (Stats.TotalParries - 1)) + flatDistance) / Stats.TotalParries
                
                if flatDistance < Stats.FastestParry then
                    Stats.FastestParry = flatDistance
                end
            end
        end
    end
    
    LastBallColor = ballColor
    PreviousPosition = currentPos
end)

task.wait(1)
JmodsLib:Notify({
    Title = "JDeath BallMods Listo",
    Content = "Auto Walk | Auto Parry | 11 Visuales Diferentes",
    Duration = 6
})
